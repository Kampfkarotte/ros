// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/base.h"
#include "Goal.pypp.hpp"

namespace bp = boost::python;

struct Goal_wrapper : ompl::base::Goal, bp::wrapper< ompl::base::Goal > {

    Goal_wrapper(::ompl::base::SpaceInformationPtr const & si )
    : ompl::base::Goal( si )
      , bp::wrapper< ompl::base::Goal >(){
        // constructor
    
    }

    virtual bool isSatisfied( ::ompl::base::State const * st ) const {
        bp::override func_isSatisfied = this->get_override( "isSatisfied" );
        return func_isSatisfied( boost::python::ptr(st) );
    }

    virtual bool isSatisfied( ::ompl::base::State const * st, double * distance ) const  {
        if( bp::override func_isSatisfied = this->get_override( "isSatisfied" ) )
            return func_isSatisfied( boost::python::ptr(st), distance );
        else{
            return this->ompl::base::Goal::isSatisfied( boost::python::ptr(st), distance );
        }
    }
    
    bool default_isSatisfied( ::ompl::base::State const * st, double * distance ) const  {
        return ompl::base::Goal::isSatisfied( boost::python::ptr(st), distance );
    }

    virtual bool isStartGoalPairValid( ::ompl::base::State const * arg0, ::ompl::base::State const * arg1 ) const  {
        if( bp::override func_isStartGoalPairValid = this->get_override( "isStartGoalPairValid" ) )
            return func_isStartGoalPairValid( boost::python::ptr(arg0), boost::python::ptr(arg1) );
        else{
            return this->ompl::base::Goal::isStartGoalPairValid( boost::python::ptr(arg0), boost::python::ptr(arg1) );
        }
    }
    
    bool default_isStartGoalPairValid( ::ompl::base::State const * arg0, ::ompl::base::State const * arg1 ) const  {
        return ompl::base::Goal::isStartGoalPairValid( boost::python::ptr(arg0), boost::python::ptr(arg1) );
    }

};

std::string __str__(::ompl::base::Goal* obj)
{
    std::ostringstream s;
    obj->print(s);
    return s.str();
}

void register_Goal_class(){

    { //::ompl::base::Goal
        typedef bp::class_< Goal_wrapper, boost::noncopyable > Goal_exposer_t;
        Goal_exposer_t Goal_exposer = Goal_exposer_t( "Goal", bp::init< ompl::base::SpaceInformationPtr const & >(( bp::arg("si") )) );
        bp::scope Goal_scope( Goal_exposer );
        { //::ompl::base::Goal::getSpaceInformation
        
            typedef ::ompl::base::SpaceInformationPtr const & ( ::ompl::base::Goal::*getSpaceInformation_function_type)(  ) const;
            
            Goal_exposer.def( 
                "getSpaceInformation"
                , getSpaceInformation_function_type( &::ompl::base::Goal::getSpaceInformation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::Goal::getType
        
            typedef ::ompl::base::GoalType ( ::ompl::base::Goal::*getType_function_type)(  ) const;
            
            Goal_exposer.def( 
                "getType"
                , getType_function_type( &::ompl::base::Goal::getType ) );
        
        }
        { //::ompl::base::Goal::hasType
        
            typedef bool ( ::ompl::base::Goal::*hasType_function_type)( ::ompl::base::GoalType ) const;
            
            Goal_exposer.def( 
                "hasType"
                , hasType_function_type( &::ompl::base::Goal::hasType )
                , ( bp::arg("type") ) );
        
        }
        { //::ompl::base::Goal::isSatisfied
        
            typedef bool ( ::ompl::base::Goal::*isSatisfied_function_type)( ::ompl::base::State const * ) const;
            
            Goal_exposer.def( 
                "isSatisfied"
                , bp::pure_virtual( isSatisfied_function_type(&::ompl::base::Goal::isSatisfied) )
                , ( bp::arg("st") ) );
        
        }
        { //::ompl::base::Goal::isSatisfied
        
            typedef bool ( ::ompl::base::Goal::*isSatisfied_function_type)( ::ompl::base::State const *,double * ) const;
            typedef bool ( Goal_wrapper::*default_isSatisfied_function_type)( ::ompl::base::State const *,double * ) const;
            
            Goal_exposer.def( 
                "isSatisfied"
                , isSatisfied_function_type(&::ompl::base::Goal::isSatisfied)
                , default_isSatisfied_function_type(&Goal_wrapper::default_isSatisfied)
                , ( bp::arg("st"), bp::arg("distance") ) );
        
        }
        { //::ompl::base::Goal::isStartGoalPairValid
        
            typedef bool ( ::ompl::base::Goal::*isStartGoalPairValid_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            typedef bool ( Goal_wrapper::*default_isStartGoalPairValid_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            
            Goal_exposer.def( 
                "isStartGoalPairValid"
                , isStartGoalPairValid_function_type(&::ompl::base::Goal::isStartGoalPairValid)
                , default_isStartGoalPairValid_function_type(&Goal_wrapper::default_isStartGoalPairValid)
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< ompl::base::Goal > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::GoalRegion >, boost::shared_ptr< ompl::base::Goal > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::GoalSampleableRegion >, boost::shared_ptr< ompl::base::Goal > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::GoalState >, boost::shared_ptr< ompl::base::Goal > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::GoalStates >, boost::shared_ptr< ompl::base::Goal > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::GoalLazySamples >, boost::shared_ptr< ompl::base::Goal > >();
        Goal_exposer.def("__str__", &__str__);
    }

}
