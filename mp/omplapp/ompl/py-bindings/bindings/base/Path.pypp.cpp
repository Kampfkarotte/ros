// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/base.h"
#include "Path.pypp.hpp"

namespace bp = boost::python;

struct Path_wrapper : ompl::base::Path, bp::wrapper< ompl::base::Path > {

    Path_wrapper(::ompl::base::SpaceInformationPtr const & si )
    : ompl::base::Path( si )
      , bp::wrapper< ompl::base::Path >(){
        // constructor
    
    }

    virtual bool check(  ) const {
        bp::override func_check = this->get_override( "check" );
        return func_check(  );
    }

    virtual ::ompl::base::Cost cost( ::ompl::base::OptimizationObjectivePtr const & obj ) const  {
        if( bp::override func_cost = this->get_override( "cost" ) )
            return func_cost( obj );
        else{
            return this->ompl::base::Path::cost( obj );
        }
    }
    
    ::ompl::base::Cost default_cost( ::ompl::base::OptimizationObjectivePtr const & obj ) const  {
        return ompl::base::Path::cost( obj );
    }

    virtual double length(  ) const {
        bp::override func_length = this->get_override( "length" );
        return func_length(  );
    }

    virtual void print(std::ostream&) const {}

};

std::string __str__(::ompl::base::Path* obj)
        {
            std::ostringstream s;
            obj->print(s);
            return s.str();
        }

void register_Path_class(){

    { //::ompl::base::Path
        typedef bp::class_< Path_wrapper, boost::noncopyable > Path_exposer_t;
        Path_exposer_t Path_exposer = Path_exposer_t( "Path", bp::init< ompl::base::SpaceInformationPtr const & >(( bp::arg("si") )) );
        bp::scope Path_scope( Path_exposer );
        { //::ompl::base::Path::check
        
            typedef bool ( ::ompl::base::Path::*check_function_type)(  ) const;
            
            Path_exposer.def( 
                "check"
                , bp::pure_virtual( check_function_type(&::ompl::base::Path::check) ) );
        
        }
        { //::ompl::base::Path::cost
        
            typedef ::ompl::base::Cost ( ::ompl::base::Path::*cost_function_type)( ::ompl::base::OptimizationObjectivePtr const & ) const;
            typedef ::ompl::base::Cost ( Path_wrapper::*default_cost_function_type)( ::ompl::base::OptimizationObjectivePtr const & ) const;
            
            Path_exposer.def( 
                "cost"
                , cost_function_type(&::ompl::base::Path::cost)
                , default_cost_function_type(&Path_wrapper::default_cost)
                , ( bp::arg("obj") ) );
        
        }
        { //::ompl::base::Path::getSpaceInformation
        
            typedef ::ompl::base::SpaceInformationPtr const & ( ::ompl::base::Path::*getSpaceInformation_function_type)(  ) const;
            
            Path_exposer.def( 
                "getSpaceInformation"
                , getSpaceInformation_function_type( &::ompl::base::Path::getSpaceInformation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::Path::length
        
            typedef double ( ::ompl::base::Path::*length_function_type)(  ) const;
            
            Path_exposer.def( 
                "length"
                , bp::pure_virtual( length_function_type(&::ompl::base::Path::length) ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< ompl::base::Path > >();
        Path_exposer.def("__str__", bp::pure_virtual(&__str__));
    }

}
