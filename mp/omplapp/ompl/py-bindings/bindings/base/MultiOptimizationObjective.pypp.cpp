// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/base.h"
#include "MultiOptimizationObjective.pypp.hpp"

namespace bp = boost::python;

struct MultiOptimizationObjective_wrapper : ompl::base::MultiOptimizationObjective, bp::wrapper< ompl::base::MultiOptimizationObjective > {

    MultiOptimizationObjective_wrapper(::ompl::base::SpaceInformationPtr const & si )
    : ompl::base::MultiOptimizationObjective( si )
      , bp::wrapper< ompl::base::MultiOptimizationObjective >(){
        // constructor
    
    }

    virtual ::ompl::base::Cost motionCost( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const  {
        if( bp::override func_motionCost = this->get_override( "motionCost" ) )
            return func_motionCost( boost::python::ptr(s1), boost::python::ptr(s2) );
        else{
            return this->ompl::base::MultiOptimizationObjective::motionCost( boost::python::ptr(s1), boost::python::ptr(s2) );
        }
    }
    
    ::ompl::base::Cost default_motionCost( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const  {
        return ompl::base::MultiOptimizationObjective::motionCost( boost::python::ptr(s1), boost::python::ptr(s2) );
    }

    virtual ::ompl::base::Cost stateCost( ::ompl::base::State const * s ) const  {
        if( bp::override func_stateCost = this->get_override( "stateCost" ) )
            return func_stateCost( boost::python::ptr(s) );
        else{
            return this->ompl::base::MultiOptimizationObjective::stateCost( boost::python::ptr(s) );
        }
    }
    
    ::ompl::base::Cost default_stateCost( ::ompl::base::State const * s ) const  {
        return ompl::base::MultiOptimizationObjective::stateCost( boost::python::ptr(s) );
    }

    virtual ::ompl::base::Cost averageStateCost( unsigned int numStates ) const  {
        if( bp::override func_averageStateCost = this->get_override( "averageStateCost" ) )
            return func_averageStateCost( numStates );
        else{
            return this->ompl::base::OptimizationObjective::averageStateCost( numStates );
        }
    }
    
    ::ompl::base::Cost default_averageStateCost( unsigned int numStates ) const  {
        return ompl::base::OptimizationObjective::averageStateCost( numStates );
    }

    virtual ::ompl::base::Cost combineCosts( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        if( bp::override func_combineCosts = this->get_override( "combineCosts" ) )
            return func_combineCosts( c1, c2 );
        else{
            return this->ompl::base::OptimizationObjective::combineCosts( c1, c2 );
        }
    }
    
    ::ompl::base::Cost default_combineCosts( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        return ompl::base::OptimizationObjective::combineCosts( c1, c2 );
    }

    virtual ::ompl::base::Cost getCost( ::ompl::base::Path const & path ) const  {
        if( bp::override func_getCost = this->get_override( "getCost" ) )
            return func_getCost( boost::ref(path) );
        else{
            return this->ompl::base::OptimizationObjective::getCost( boost::ref(path) );
        }
    }
    
    ::ompl::base::Cost default_getCost( ::ompl::base::Path const & path ) const  {
        return ompl::base::OptimizationObjective::getCost( boost::ref(path) );
    }

    virtual ::ompl::base::Cost identityCost(  ) const  {
        if( bp::override func_identityCost = this->get_override( "identityCost" ) )
            return func_identityCost(  );
        else{
            return this->ompl::base::OptimizationObjective::identityCost(  );
        }
    }
    
    ::ompl::base::Cost default_identityCost(  ) const  {
        return ompl::base::OptimizationObjective::identityCost( );
    }

    virtual ::ompl::base::Cost infiniteCost(  ) const  {
        if( bp::override func_infiniteCost = this->get_override( "infiniteCost" ) )
            return func_infiniteCost(  );
        else{
            return this->ompl::base::OptimizationObjective::infiniteCost(  );
        }
    }
    
    ::ompl::base::Cost default_infiniteCost(  ) const  {
        return ompl::base::OptimizationObjective::infiniteCost( );
    }

    virtual ::ompl::base::Cost initialCost( ::ompl::base::State const * s ) const  {
        if( bp::override func_initialCost = this->get_override( "initialCost" ) )
            return func_initialCost( boost::python::ptr(s) );
        else{
            return this->ompl::base::OptimizationObjective::initialCost( boost::python::ptr(s) );
        }
    }
    
    ::ompl::base::Cost default_initialCost( ::ompl::base::State const * s ) const  {
        return ompl::base::OptimizationObjective::initialCost( boost::python::ptr(s) );
    }

    virtual bool isCostBetterThan( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        if( bp::override func_isCostBetterThan = this->get_override( "isCostBetterThan" ) )
            return func_isCostBetterThan( c1, c2 );
        else{
            return this->ompl::base::OptimizationObjective::isCostBetterThan( c1, c2 );
        }
    }
    
    bool default_isCostBetterThan( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        return ompl::base::OptimizationObjective::isCostBetterThan( c1, c2 );
    }

    virtual bool isSatisfied( ::ompl::base::Cost c ) const  {
        if( bp::override func_isSatisfied = this->get_override( "isSatisfied" ) )
            return func_isSatisfied( c );
        else{
            return this->ompl::base::OptimizationObjective::isSatisfied( c );
        }
    }
    
    bool default_isSatisfied( ::ompl::base::Cost c ) const  {
        return ompl::base::OptimizationObjective::isSatisfied( c );
    }

    virtual bool isSymmetric(  ) const  {
        if( bp::override func_isSymmetric = this->get_override( "isSymmetric" ) )
            return func_isSymmetric(  );
        else{
            return this->ompl::base::OptimizationObjective::isSymmetric(  );
        }
    }
    
    bool default_isSymmetric(  ) const  {
        return ompl::base::OptimizationObjective::isSymmetric( );
    }

    virtual ::ompl::base::Cost motionCostHeuristic( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const  {
        if( bp::override func_motionCostHeuristic = this->get_override( "motionCostHeuristic" ) )
            return func_motionCostHeuristic( boost::python::ptr(s1), boost::python::ptr(s2) );
        else{
            return this->ompl::base::OptimizationObjective::motionCostHeuristic( boost::python::ptr(s1), boost::python::ptr(s2) );
        }
    }
    
    ::ompl::base::Cost default_motionCostHeuristic( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const  {
        return ompl::base::OptimizationObjective::motionCostHeuristic( boost::python::ptr(s1), boost::python::ptr(s2) );
    }

    virtual ::ompl::base::Cost terminalCost( ::ompl::base::State const * s ) const  {
        if( bp::override func_terminalCost = this->get_override( "terminalCost" ) )
            return func_terminalCost( boost::python::ptr(s) );
        else{
            return this->ompl::base::OptimizationObjective::terminalCost( boost::python::ptr(s) );
        }
    }
    
    ::ompl::base::Cost default_terminalCost( ::ompl::base::State const * s ) const  {
        return ompl::base::OptimizationObjective::terminalCost( boost::python::ptr(s) );
    }

};

void register_MultiOptimizationObjective_class(){

    { //::ompl::base::MultiOptimizationObjective
        typedef bp::class_< MultiOptimizationObjective_wrapper, bp::bases< ompl::base::OptimizationObjective >, boost::noncopyable > MultiOptimizationObjective_exposer_t;
        MultiOptimizationObjective_exposer_t MultiOptimizationObjective_exposer = MultiOptimizationObjective_exposer_t( "MultiOptimizationObjective", bp::init< ompl::base::SpaceInformationPtr const & >(( bp::arg("si") )) );
        bp::scope MultiOptimizationObjective_scope( MultiOptimizationObjective_exposer );
        bp::implicitly_convertible< ompl::base::SpaceInformationPtr const &, ompl::base::MultiOptimizationObjective >();
        { //::ompl::base::MultiOptimizationObjective::addObjective
        
            typedef void ( ::ompl::base::MultiOptimizationObjective::*addObjective_function_type)( ::ompl::base::OptimizationObjectivePtr const &,double ) ;
            
            MultiOptimizationObjective_exposer.def( 
                "addObjective"
                , addObjective_function_type( &::ompl::base::MultiOptimizationObjective::addObjective )
                , ( bp::arg("objective"), bp::arg("weight") ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::getObjective
        
            typedef ::ompl::base::OptimizationObjectivePtr const & ( ::ompl::base::MultiOptimizationObjective::*getObjective_function_type)( unsigned int ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "getObjective"
                , getObjective_function_type( &::ompl::base::MultiOptimizationObjective::getObjective )
                , ( bp::arg("idx") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::MultiOptimizationObjective::getObjectiveCount
        
            typedef ::std::size_t ( ::ompl::base::MultiOptimizationObjective::*getObjectiveCount_function_type)(  ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "getObjectiveCount"
                , getObjectiveCount_function_type( &::ompl::base::MultiOptimizationObjective::getObjectiveCount ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::getObjectiveWeight
        
            typedef double ( ::ompl::base::MultiOptimizationObjective::*getObjectiveWeight_function_type)( unsigned int ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "getObjectiveWeight"
                , getObjectiveWeight_function_type( &::ompl::base::MultiOptimizationObjective::getObjectiveWeight )
                , ( bp::arg("idx") ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::isLocked
        
            typedef bool ( ::ompl::base::MultiOptimizationObjective::*isLocked_function_type)(  ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "isLocked"
                , isLocked_function_type( &::ompl::base::MultiOptimizationObjective::isLocked ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::lock
        
            typedef void ( ::ompl::base::MultiOptimizationObjective::*lock_function_type)(  ) ;
            
            MultiOptimizationObjective_exposer.def( 
                "lock"
                , lock_function_type( &::ompl::base::MultiOptimizationObjective::lock ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::motionCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::MultiOptimizationObjective::*motionCost_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_motionCost_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "motionCost"
                , motionCost_function_type(&::ompl::base::MultiOptimizationObjective::motionCost)
                , default_motionCost_function_type(&MultiOptimizationObjective_wrapper::default_motionCost)
                , ( bp::arg("s1"), bp::arg("s2") ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::setObjectiveWeight
        
            typedef void ( ::ompl::base::MultiOptimizationObjective::*setObjectiveWeight_function_type)( unsigned int,double ) ;
            
            MultiOptimizationObjective_exposer.def( 
                "setObjectiveWeight"
                , setObjectiveWeight_function_type( &::ompl::base::MultiOptimizationObjective::setObjectiveWeight )
                , ( bp::arg("idx"), bp::arg("weight") ) );
        
        }
        { //::ompl::base::MultiOptimizationObjective::stateCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::MultiOptimizationObjective::*stateCost_function_type)( ::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_stateCost_function_type)( ::ompl::base::State const * ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "stateCost"
                , stateCost_function_type(&::ompl::base::MultiOptimizationObjective::stateCost)
                , default_stateCost_function_type(&MultiOptimizationObjective_wrapper::default_stateCost)
                , ( bp::arg("s") ) );
        
        }
        { //::ompl::base::OptimizationObjective::averageStateCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*averageStateCost_function_type)( unsigned int ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_averageStateCost_function_type)( unsigned int ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "averageStateCost"
                , averageStateCost_function_type(&::ompl::base::OptimizationObjective::averageStateCost)
                , default_averageStateCost_function_type(&MultiOptimizationObjective_wrapper::default_averageStateCost)
                , ( bp::arg("numStates") ) );
        
        }
        { //::ompl::base::OptimizationObjective::combineCosts
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*combineCosts_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_combineCosts_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "combineCosts"
                , combineCosts_function_type(&::ompl::base::OptimizationObjective::combineCosts)
                , default_combineCosts_function_type(&MultiOptimizationObjective_wrapper::default_combineCosts)
                , ( bp::arg("c1"), bp::arg("c2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::getCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*getCost_function_type)( ::ompl::base::Path const & ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_getCost_function_type)( ::ompl::base::Path const & ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "getCost"
                , getCost_function_type(&::ompl::base::OptimizationObjective::getCost)
                , default_getCost_function_type(&MultiOptimizationObjective_wrapper::default_getCost)
                , ( bp::arg("path") ) );
        
        }
        { //::ompl::base::OptimizationObjective::identityCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*identityCost_function_type)(  ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_identityCost_function_type)(  ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "identityCost"
                , identityCost_function_type(&::ompl::base::OptimizationObjective::identityCost)
                , default_identityCost_function_type(&MultiOptimizationObjective_wrapper::default_identityCost) );
        
        }
        { //::ompl::base::OptimizationObjective::infiniteCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*infiniteCost_function_type)(  ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_infiniteCost_function_type)(  ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "infiniteCost"
                , infiniteCost_function_type(&::ompl::base::OptimizationObjective::infiniteCost)
                , default_infiniteCost_function_type(&MultiOptimizationObjective_wrapper::default_infiniteCost) );
        
        }
        { //::ompl::base::OptimizationObjective::initialCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*initialCost_function_type)( ::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_initialCost_function_type)( ::ompl::base::State const * ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "initialCost"
                , initialCost_function_type(&::ompl::base::OptimizationObjective::initialCost)
                , default_initialCost_function_type(&MultiOptimizationObjective_wrapper::default_initialCost)
                , ( bp::arg("s") ) );
        
        }
        { //::ompl::base::OptimizationObjective::isCostBetterThan
        
            typedef bool ( ::ompl::base::OptimizationObjective::*isCostBetterThan_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            typedef bool ( MultiOptimizationObjective_wrapper::*default_isCostBetterThan_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "isCostBetterThan"
                , isCostBetterThan_function_type(&::ompl::base::OptimizationObjective::isCostBetterThan)
                , default_isCostBetterThan_function_type(&MultiOptimizationObjective_wrapper::default_isCostBetterThan)
                , ( bp::arg("c1"), bp::arg("c2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::isSatisfied
        
            typedef bool ( ::ompl::base::OptimizationObjective::*isSatisfied_function_type)( ::ompl::base::Cost ) const;
            typedef bool ( MultiOptimizationObjective_wrapper::*default_isSatisfied_function_type)( ::ompl::base::Cost ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "isSatisfied"
                , isSatisfied_function_type(&::ompl::base::OptimizationObjective::isSatisfied)
                , default_isSatisfied_function_type(&MultiOptimizationObjective_wrapper::default_isSatisfied)
                , ( bp::arg("c") ) );
        
        }
        { //::ompl::base::OptimizationObjective::isSymmetric
        
            typedef bool ( ::ompl::base::OptimizationObjective::*isSymmetric_function_type)(  ) const;
            typedef bool ( MultiOptimizationObjective_wrapper::*default_isSymmetric_function_type)(  ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "isSymmetric"
                , isSymmetric_function_type(&::ompl::base::OptimizationObjective::isSymmetric)
                , default_isSymmetric_function_type(&MultiOptimizationObjective_wrapper::default_isSymmetric) );
        
        }
        { //::ompl::base::OptimizationObjective::motionCostHeuristic
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*motionCostHeuristic_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_motionCostHeuristic_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "motionCostHeuristic"
                , motionCostHeuristic_function_type(&::ompl::base::OptimizationObjective::motionCostHeuristic)
                , default_motionCostHeuristic_function_type(&MultiOptimizationObjective_wrapper::default_motionCostHeuristic)
                , ( bp::arg("s1"), bp::arg("s2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::terminalCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*terminalCost_function_type)( ::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( MultiOptimizationObjective_wrapper::*default_terminalCost_function_type)( ::ompl::base::State const * ) const;
            
            MultiOptimizationObjective_exposer.def( 
                "terminalCost"
                , terminalCost_function_type(&::ompl::base::OptimizationObjective::terminalCost)
                , default_terminalCost_function_type(&MultiOptimizationObjective_wrapper::default_terminalCost)
                , ( bp::arg("s") ) );
        
        }
    }

}
