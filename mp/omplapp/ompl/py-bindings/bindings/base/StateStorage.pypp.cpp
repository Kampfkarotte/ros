// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/base.h"
#include "StateStorage.pypp.hpp"

namespace bp = boost::python;

struct StateStorage_wrapper : ompl::base::StateStorage, bp::wrapper< ompl::base::StateStorage > {

    StateStorage_wrapper(ompl::base::StateStorage const & arg )
    : ompl::base::StateStorage( arg )
      , bp::wrapper< ompl::base::StateStorage >(){
        // copy constructor
        
    }

    StateStorage_wrapper(::ompl::base::StateSpacePtr const & space )
    : ompl::base::StateStorage( space )
      , bp::wrapper< ompl::base::StateStorage >(){
        // constructor
    
    }

    virtual void addState( ::ompl::base::State const * state ) {
        if( bp::override func_addState = this->get_override( "addState" ) )
            func_addState( boost::python::ptr(state) );
        else{
            this->ompl::base::StateStorage::addState( boost::python::ptr(state) );
        }
    }
    
    void default_addState( ::ompl::base::State const * state ) {
        ompl::base::StateStorage::addState( boost::python::ptr(state) );
    }

    virtual void clear(  ) {
        if( bp::override func_clear = this->get_override( "clear" ) )
            func_clear(  );
        else{
            this->ompl::base::StateStorage::clear(  );
        }
    }
    
    void default_clear(  ) {
        ompl::base::StateStorage::clear( );
    }

    void freeMemory(  ){
        ompl::base::StateStorage::freeMemory(  );
    }

    virtual void generateSamples( unsigned int count ) {
        if( bp::override func_generateSamples = this->get_override( "generateSamples" ) )
            func_generateSamples( count );
        else{
            this->ompl::base::StateStorage::generateSamples( count );
        }
    }
    
    void default_generateSamples( unsigned int count ) {
        ompl::base::StateStorage::generateSamples( count );
    }

};

std::string __str__(::ompl::base::StateStorage* obj)
{
    std::ostringstream s;
    obj->print(s);
    return s.str();
}

void register_StateStorage_class(){

    { //::ompl::base::StateStorage
        typedef bp::class_< StateStorage_wrapper > StateStorage_exposer_t;
        StateStorage_exposer_t StateStorage_exposer = StateStorage_exposer_t( "StateStorage", bp::init< ompl::base::StateSpacePtr const & >(( bp::arg("space") )) );
        bp::scope StateStorage_scope( StateStorage_exposer );
        bp::implicitly_convertible< ompl::base::StateSpacePtr const &, ompl::base::StateStorage >();
        { //::ompl::base::StateStorage::addState
        
            typedef void ( ::ompl::base::StateStorage::*addState_function_type)( ::ompl::base::State const * ) ;
            typedef void ( StateStorage_wrapper::*default_addState_function_type)( ::ompl::base::State const * ) ;
            
            StateStorage_exposer.def( 
                "addState"
                , addState_function_type(&::ompl::base::StateStorage::addState)
                , default_addState_function_type(&StateStorage_wrapper::default_addState)
                , ( bp::arg("state") ) );
        
        }
        { //::ompl::base::StateStorage::clear
        
            typedef void ( ::ompl::base::StateStorage::*clear_function_type)(  ) ;
            typedef void ( StateStorage_wrapper::*default_clear_function_type)(  ) ;
            
            StateStorage_exposer.def( 
                "clear"
                , clear_function_type(&::ompl::base::StateStorage::clear)
                , default_clear_function_type(&StateStorage_wrapper::default_clear) );
        
        }
        { //::ompl::base::StateStorage::freeMemory
        
            typedef void ( StateStorage_wrapper::*freeMemory_function_type)(  ) ;
            
            StateStorage_exposer.def( 
                "freeMemory"
                , freeMemory_function_type( &StateStorage_wrapper::freeMemory ) );
        
        }
        { //::ompl::base::StateStorage::generateSamples
        
            typedef void ( ::ompl::base::StateStorage::*generateSamples_function_type)( unsigned int ) ;
            typedef void ( StateStorage_wrapper::*default_generateSamples_function_type)( unsigned int ) ;
            
            StateStorage_exposer.def( 
                "generateSamples"
                , generateSamples_function_type(&::ompl::base::StateStorage::generateSamples)
                , default_generateSamples_function_type(&StateStorage_wrapper::default_generateSamples)
                , ( bp::arg("count") ) );
        
        }
        { //::ompl::base::StateStorage::getState
        
            typedef ::ompl::base::State * ( ::ompl::base::StateStorage::*getState_function_type)( unsigned int ) ;
            
            StateStorage_exposer.def( 
                "getState"
                , getState_function_type( &::ompl::base::StateStorage::getState )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ompl::base::StateStorage::getState
        
            typedef ::ompl::base::State const * ( ::ompl::base::StateStorage::*getState_function_type)( unsigned int ) const;
            
            StateStorage_exposer.def( 
                "getState"
                , getState_function_type( &::ompl::base::StateStorage::getState )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ompl::base::StateStorage::getStateSamplerAllocator
        
            typedef ::ompl::base::StateSamplerAllocator ( ::ompl::base::StateStorage::*getStateSamplerAllocator_function_type)(  ) const;
            
            StateStorage_exposer.def( 
                "getStateSamplerAllocator"
                , getStateSamplerAllocator_function_type( &::ompl::base::StateStorage::getStateSamplerAllocator ) );
        
        }
        { //::ompl::base::StateStorage::getStateSamplerAllocatorRangeAfter
        
            typedef ::ompl::base::StateSamplerAllocator ( ::ompl::base::StateStorage::*getStateSamplerAllocatorRangeAfter_function_type)( ::std::size_t ) const;
            
            StateStorage_exposer.def( 
                "getStateSamplerAllocatorRangeAfter"
                , getStateSamplerAllocatorRangeAfter_function_type( &::ompl::base::StateStorage::getStateSamplerAllocatorRangeAfter )
                , ( bp::arg("after") ) );
        
        }
        { //::ompl::base::StateStorage::getStateSamplerAllocatorRangeUntil
        
            typedef ::ompl::base::StateSamplerAllocator ( ::ompl::base::StateStorage::*getStateSamplerAllocatorRangeUntil_function_type)( ::std::size_t ) const;
            
            StateStorage_exposer.def( 
                "getStateSamplerAllocatorRangeUntil"
                , getStateSamplerAllocatorRangeUntil_function_type( &::ompl::base::StateStorage::getStateSamplerAllocatorRangeUntil )
                , ( bp::arg("until") ) );
        
        }
        { //::ompl::base::StateStorage::getStateSpace
        
            typedef ::ompl::base::StateSpacePtr const & ( ::ompl::base::StateStorage::*getStateSpace_function_type)(  ) const;
            
            StateStorage_exposer.def( 
                "getStateSpace"
                , getStateSpace_function_type( &::ompl::base::StateStorage::getStateSpace )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::StateStorage::getStates
        
            typedef ::std::vector< ompl::base::State const* > const & ( ::ompl::base::StateStorage::*getStates_function_type)(  ) const;
            
            StateStorage_exposer.def( 
                "getStates"
                , getStates_function_type( &::ompl::base::StateStorage::getStates )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::StateStorage::hasMetadata
        
            typedef bool ( ::ompl::base::StateStorage::*hasMetadata_function_type)(  ) const;
            
            StateStorage_exposer.def( 
                "hasMetadata"
                , hasMetadata_function_type( &::ompl::base::StateStorage::hasMetadata ) );
        
        }
        { //::ompl::base::StateStorage::load
        
            typedef void ( ::ompl::base::StateStorage::*load_function_type)( char const * ) ;
            
            StateStorage_exposer.def( 
                "load"
                , load_function_type( &::ompl::base::StateStorage::load )
                , ( bp::arg("filename") ) );
        
        }
        { //::ompl::base::StateStorage::size
        
            typedef ::std::size_t ( ::ompl::base::StateStorage::*size_function_type)(  ) const;
            
            StateStorage_exposer.def( 
                "size"
                , size_function_type( &::ompl::base::StateStorage::size ) );
        
        }
        { //::ompl::base::StateStorage::sort
        
            typedef void ( ::ompl::base::StateStorage::*sort_function_type)( ::boost::function< bool (const ompl::base::State*, const ompl::base::State*) > const & ) ;
            
            StateStorage_exposer.def( 
                "sort"
                , sort_function_type( &::ompl::base::StateStorage::sort )
                , ( bp::arg("op") ) );
        
        }
        { //::ompl::base::StateStorage::store
        
            typedef void ( ::ompl::base::StateStorage::*store_function_type)( char const * ) ;
            
            StateStorage_exposer.def( 
                "store"
                , store_function_type( &::ompl::base::StateStorage::store )
                , ( bp::arg("filename") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< ompl::base::StateStorage > >();
        StateStorage_exposer.def("getStateSamplerAllocatorRange", &ompl::base::StateStorage::getStateSamplerAllocatorRange);
        StateStorage_exposer.def("__str__", &__str__);
    }

}
