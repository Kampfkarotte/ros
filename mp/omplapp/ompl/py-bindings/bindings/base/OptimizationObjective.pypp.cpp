// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/base.h"
#include "OptimizationObjective.pypp.hpp"

namespace bp = boost::python;

struct OptimizationObjective_wrapper : ompl::base::OptimizationObjective, bp::wrapper< ompl::base::OptimizationObjective > {

    OptimizationObjective_wrapper(::ompl::base::SpaceInformationPtr const & si )
    : ompl::base::OptimizationObjective( si )
      , bp::wrapper< ompl::base::OptimizationObjective >(){
        // constructor
    
    }

    virtual ::ompl::base::Cost averageStateCost( unsigned int numStates ) const  {
        if( bp::override func_averageStateCost = this->get_override( "averageStateCost" ) )
            return func_averageStateCost( numStates );
        else{
            return this->ompl::base::OptimizationObjective::averageStateCost( numStates );
        }
    }
    
    ::ompl::base::Cost default_averageStateCost( unsigned int numStates ) const  {
        return ompl::base::OptimizationObjective::averageStateCost( numStates );
    }

    virtual ::ompl::base::Cost combineCosts( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        if( bp::override func_combineCosts = this->get_override( "combineCosts" ) )
            return func_combineCosts( c1, c2 );
        else{
            return this->ompl::base::OptimizationObjective::combineCosts( c1, c2 );
        }
    }
    
    ::ompl::base::Cost default_combineCosts( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        return ompl::base::OptimizationObjective::combineCosts( c1, c2 );
    }

    virtual ::ompl::base::Cost getCost( ::ompl::base::Path const & path ) const  {
        if( bp::override func_getCost = this->get_override( "getCost" ) )
            return func_getCost( boost::ref(path) );
        else{
            return this->ompl::base::OptimizationObjective::getCost( boost::ref(path) );
        }
    }
    
    ::ompl::base::Cost default_getCost( ::ompl::base::Path const & path ) const  {
        return ompl::base::OptimizationObjective::getCost( boost::ref(path) );
    }

    virtual ::ompl::base::Cost identityCost(  ) const  {
        if( bp::override func_identityCost = this->get_override( "identityCost" ) )
            return func_identityCost(  );
        else{
            return this->ompl::base::OptimizationObjective::identityCost(  );
        }
    }
    
    ::ompl::base::Cost default_identityCost(  ) const  {
        return ompl::base::OptimizationObjective::identityCost( );
    }

    virtual ::ompl::base::Cost infiniteCost(  ) const  {
        if( bp::override func_infiniteCost = this->get_override( "infiniteCost" ) )
            return func_infiniteCost(  );
        else{
            return this->ompl::base::OptimizationObjective::infiniteCost(  );
        }
    }
    
    ::ompl::base::Cost default_infiniteCost(  ) const  {
        return ompl::base::OptimizationObjective::infiniteCost( );
    }

    virtual ::ompl::base::Cost initialCost( ::ompl::base::State const * s ) const  {
        if( bp::override func_initialCost = this->get_override( "initialCost" ) )
            return func_initialCost( boost::python::ptr(s) );
        else{
            return this->ompl::base::OptimizationObjective::initialCost( boost::python::ptr(s) );
        }
    }
    
    ::ompl::base::Cost default_initialCost( ::ompl::base::State const * s ) const  {
        return ompl::base::OptimizationObjective::initialCost( boost::python::ptr(s) );
    }

    virtual bool isCostBetterThan( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        if( bp::override func_isCostBetterThan = this->get_override( "isCostBetterThan" ) )
            return func_isCostBetterThan( c1, c2 );
        else{
            return this->ompl::base::OptimizationObjective::isCostBetterThan( c1, c2 );
        }
    }
    
    bool default_isCostBetterThan( ::ompl::base::Cost c1, ::ompl::base::Cost c2 ) const  {
        return ompl::base::OptimizationObjective::isCostBetterThan( c1, c2 );
    }

    virtual bool isSatisfied( ::ompl::base::Cost c ) const  {
        if( bp::override func_isSatisfied = this->get_override( "isSatisfied" ) )
            return func_isSatisfied( c );
        else{
            return this->ompl::base::OptimizationObjective::isSatisfied( c );
        }
    }
    
    bool default_isSatisfied( ::ompl::base::Cost c ) const  {
        return ompl::base::OptimizationObjective::isSatisfied( c );
    }

    virtual bool isSymmetric(  ) const  {
        if( bp::override func_isSymmetric = this->get_override( "isSymmetric" ) )
            return func_isSymmetric(  );
        else{
            return this->ompl::base::OptimizationObjective::isSymmetric(  );
        }
    }
    
    bool default_isSymmetric(  ) const  {
        return ompl::base::OptimizationObjective::isSymmetric( );
    }

    virtual ::ompl::base::Cost motionCost( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const {
        bp::override func_motionCost = this->get_override( "motionCost" );
        return func_motionCost( boost::python::ptr(s1), boost::python::ptr(s2) );
    }

    virtual ::ompl::base::Cost motionCostHeuristic( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const  {
        if( bp::override func_motionCostHeuristic = this->get_override( "motionCostHeuristic" ) )
            return func_motionCostHeuristic( boost::python::ptr(s1), boost::python::ptr(s2) );
        else{
            return this->ompl::base::OptimizationObjective::motionCostHeuristic( boost::python::ptr(s1), boost::python::ptr(s2) );
        }
    }
    
    ::ompl::base::Cost default_motionCostHeuristic( ::ompl::base::State const * s1, ::ompl::base::State const * s2 ) const  {
        return ompl::base::OptimizationObjective::motionCostHeuristic( boost::python::ptr(s1), boost::python::ptr(s2) );
    }

    virtual ::ompl::base::Cost stateCost( ::ompl::base::State const * s ) const  {
        if( bp::override func_stateCost = this->get_override( "stateCost" ) )
            return func_stateCost( boost::python::ptr(s) );
        else{
            return this->ompl::base::OptimizationObjective::stateCost( boost::python::ptr(s) );
        }
    }
    
    ::ompl::base::Cost default_stateCost( ::ompl::base::State const * s ) const  {
        return ompl::base::OptimizationObjective::stateCost( boost::python::ptr(s) );
    }

    virtual ::ompl::base::Cost terminalCost( ::ompl::base::State const * s ) const  {
        if( bp::override func_terminalCost = this->get_override( "terminalCost" ) )
            return func_terminalCost( boost::python::ptr(s) );
        else{
            return this->ompl::base::OptimizationObjective::terminalCost( boost::python::ptr(s) );
        }
    }
    
    ::ompl::base::Cost default_terminalCost( ::ompl::base::State const * s ) const  {
        return ompl::base::OptimizationObjective::terminalCost( boost::python::ptr(s) );
    }

};

void register_OptimizationObjective_class(){

    { //::ompl::base::OptimizationObjective
        typedef bp::class_< OptimizationObjective_wrapper, boost::noncopyable > OptimizationObjective_exposer_t;
        OptimizationObjective_exposer_t OptimizationObjective_exposer = OptimizationObjective_exposer_t( "OptimizationObjective", bp::init< ompl::base::SpaceInformationPtr const & >(( bp::arg("si") )) );
        bp::scope OptimizationObjective_scope( OptimizationObjective_exposer );
        { //::ompl::base::OptimizationObjective::averageStateCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*averageStateCost_function_type)( unsigned int ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_averageStateCost_function_type)( unsigned int ) const;
            
            OptimizationObjective_exposer.def( 
                "averageStateCost"
                , averageStateCost_function_type(&::ompl::base::OptimizationObjective::averageStateCost)
                , default_averageStateCost_function_type(&OptimizationObjective_wrapper::default_averageStateCost)
                , ( bp::arg("numStates") ) );
        
        }
        { //::ompl::base::OptimizationObjective::combineCosts
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*combineCosts_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_combineCosts_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            
            OptimizationObjective_exposer.def( 
                "combineCosts"
                , combineCosts_function_type(&::ompl::base::OptimizationObjective::combineCosts)
                , default_combineCosts_function_type(&OptimizationObjective_wrapper::default_combineCosts)
                , ( bp::arg("c1"), bp::arg("c2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::costToGo
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*costToGo_function_type)( ::ompl::base::State const *,::ompl::base::Goal const * ) const;
            
            OptimizationObjective_exposer.def( 
                "costToGo"
                , costToGo_function_type( &::ompl::base::OptimizationObjective::costToGo )
                , ( bp::arg("state"), bp::arg("goal") ) );
        
        }
        { //::ompl::base::OptimizationObjective::getCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*getCost_function_type)( ::ompl::base::Path const & ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_getCost_function_type)( ::ompl::base::Path const & ) const;
            
            OptimizationObjective_exposer.def( 
                "getCost"
                , getCost_function_type(&::ompl::base::OptimizationObjective::getCost)
                , default_getCost_function_type(&OptimizationObjective_wrapper::default_getCost)
                , ( bp::arg("path") ) );
        
        }
        { //::ompl::base::OptimizationObjective::getCostThreshold
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*getCostThreshold_function_type)(  ) const;
            
            OptimizationObjective_exposer.def( 
                "getCostThreshold"
                , getCostThreshold_function_type( &::ompl::base::OptimizationObjective::getCostThreshold ) );
        
        }
        { //::ompl::base::OptimizationObjective::getDescription
        
            typedef ::std::string const & ( ::ompl::base::OptimizationObjective::*getDescription_function_type)(  ) const;
            
            OptimizationObjective_exposer.def( 
                "getDescription"
                , getDescription_function_type( &::ompl::base::OptimizationObjective::getDescription )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::OptimizationObjective::getSpaceInformation
        
            typedef ::ompl::base::SpaceInformationPtr const & ( ::ompl::base::OptimizationObjective::*getSpaceInformation_function_type)(  ) const;
            
            OptimizationObjective_exposer.def( 
                "getSpaceInformation"
                , getSpaceInformation_function_type( &::ompl::base::OptimizationObjective::getSpaceInformation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::base::OptimizationObjective::identityCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*identityCost_function_type)(  ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_identityCost_function_type)(  ) const;
            
            OptimizationObjective_exposer.def( 
                "identityCost"
                , identityCost_function_type(&::ompl::base::OptimizationObjective::identityCost)
                , default_identityCost_function_type(&OptimizationObjective_wrapper::default_identityCost) );
        
        }
        { //::ompl::base::OptimizationObjective::infiniteCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*infiniteCost_function_type)(  ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_infiniteCost_function_type)(  ) const;
            
            OptimizationObjective_exposer.def( 
                "infiniteCost"
                , infiniteCost_function_type(&::ompl::base::OptimizationObjective::infiniteCost)
                , default_infiniteCost_function_type(&OptimizationObjective_wrapper::default_infiniteCost) );
        
        }
        { //::ompl::base::OptimizationObjective::initialCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*initialCost_function_type)( ::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_initialCost_function_type)( ::ompl::base::State const * ) const;
            
            OptimizationObjective_exposer.def( 
                "initialCost"
                , initialCost_function_type(&::ompl::base::OptimizationObjective::initialCost)
                , default_initialCost_function_type(&OptimizationObjective_wrapper::default_initialCost)
                , ( bp::arg("s") ) );
        
        }
        { //::ompl::base::OptimizationObjective::isCostBetterThan
        
            typedef bool ( ::ompl::base::OptimizationObjective::*isCostBetterThan_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            typedef bool ( OptimizationObjective_wrapper::*default_isCostBetterThan_function_type)( ::ompl::base::Cost,::ompl::base::Cost ) const;
            
            OptimizationObjective_exposer.def( 
                "isCostBetterThan"
                , isCostBetterThan_function_type(&::ompl::base::OptimizationObjective::isCostBetterThan)
                , default_isCostBetterThan_function_type(&OptimizationObjective_wrapper::default_isCostBetterThan)
                , ( bp::arg("c1"), bp::arg("c2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::isSatisfied
        
            typedef bool ( ::ompl::base::OptimizationObjective::*isSatisfied_function_type)( ::ompl::base::Cost ) const;
            typedef bool ( OptimizationObjective_wrapper::*default_isSatisfied_function_type)( ::ompl::base::Cost ) const;
            
            OptimizationObjective_exposer.def( 
                "isSatisfied"
                , isSatisfied_function_type(&::ompl::base::OptimizationObjective::isSatisfied)
                , default_isSatisfied_function_type(&OptimizationObjective_wrapper::default_isSatisfied)
                , ( bp::arg("c") ) );
        
        }
        { //::ompl::base::OptimizationObjective::isSymmetric
        
            typedef bool ( ::ompl::base::OptimizationObjective::*isSymmetric_function_type)(  ) const;
            typedef bool ( OptimizationObjective_wrapper::*default_isSymmetric_function_type)(  ) const;
            
            OptimizationObjective_exposer.def( 
                "isSymmetric"
                , isSymmetric_function_type(&::ompl::base::OptimizationObjective::isSymmetric)
                , default_isSymmetric_function_type(&OptimizationObjective_wrapper::default_isSymmetric) );
        
        }
        { //::ompl::base::OptimizationObjective::motionCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*motionCost_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            
            OptimizationObjective_exposer.def( 
                "motionCost"
                , bp::pure_virtual( motionCost_function_type(&::ompl::base::OptimizationObjective::motionCost) )
                , ( bp::arg("s1"), bp::arg("s2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::motionCostHeuristic
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*motionCostHeuristic_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_motionCostHeuristic_function_type)( ::ompl::base::State const *,::ompl::base::State const * ) const;
            
            OptimizationObjective_exposer.def( 
                "motionCostHeuristic"
                , motionCostHeuristic_function_type(&::ompl::base::OptimizationObjective::motionCostHeuristic)
                , default_motionCostHeuristic_function_type(&OptimizationObjective_wrapper::default_motionCostHeuristic)
                , ( bp::arg("s1"), bp::arg("s2") ) );
        
        }
        { //::ompl::base::OptimizationObjective::setCostThreshold
        
            typedef void ( ::ompl::base::OptimizationObjective::*setCostThreshold_function_type)( ::ompl::base::Cost ) ;
            
            OptimizationObjective_exposer.def( 
                "setCostThreshold"
                , setCostThreshold_function_type( &::ompl::base::OptimizationObjective::setCostThreshold )
                , ( bp::arg("c") ) );
        
        }
        { //::ompl::base::OptimizationObjective::setCostToGoHeuristic
        
            typedef void ( ::ompl::base::OptimizationObjective::*setCostToGoHeuristic_function_type)( ::ompl::base::CostToGoHeuristic const & ) ;
            
            OptimizationObjective_exposer.def( 
                "setCostToGoHeuristic"
                , setCostToGoHeuristic_function_type( &::ompl::base::OptimizationObjective::setCostToGoHeuristic )
                , ( bp::arg("costToGo") ) );
        
        }
        { //::ompl::base::OptimizationObjective::stateCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*stateCost_function_type)( ::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_stateCost_function_type)( ::ompl::base::State const * ) const;
            
            OptimizationObjective_exposer.def( 
                "stateCost"
                , stateCost_function_type(&::ompl::base::OptimizationObjective::stateCost)
                , default_stateCost_function_type(&OptimizationObjective_wrapper::default_stateCost)
                , ( bp::arg("s") ) );
        
        }
        { //::ompl::base::OptimizationObjective::terminalCost
        
            typedef ::ompl::base::Cost ( ::ompl::base::OptimizationObjective::*terminalCost_function_type)( ::ompl::base::State const * ) const;
            typedef ::ompl::base::Cost ( OptimizationObjective_wrapper::*default_terminalCost_function_type)( ::ompl::base::State const * ) const;
            
            OptimizationObjective_exposer.def( 
                "terminalCost"
                , terminalCost_function_type(&::ompl::base::OptimizationObjective::terminalCost)
                , default_terminalCost_function_type(&OptimizationObjective_wrapper::default_terminalCost)
                , ( bp::arg("s") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< ompl::base::OptimizationObjective > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::PathLengthOptimizationObjective >, boost::shared_ptr< ompl::base::OptimizationObjective > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::MultiOptimizationObjective >, boost::shared_ptr< ompl::base::OptimizationObjective > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::StateCostIntegralObjective >, boost::shared_ptr< ompl::base::OptimizationObjective > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::MinimaxObjective >, boost::shared_ptr< ompl::base::OptimizationObjective > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::MaximizeMinClearanceObjective >, boost::shared_ptr< ompl::base::OptimizationObjective > >();
        bp::implicitly_convertible< boost::shared_ptr< ompl::base::MechanicalWorkOptimizationObjective >, boost::shared_ptr< ompl::base::OptimizationObjective > >();
    }

}
