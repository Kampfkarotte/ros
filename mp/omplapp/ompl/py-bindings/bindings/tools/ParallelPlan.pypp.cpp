// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/tools.h"
#include "ParallelPlan.pypp.hpp"

namespace bp = boost::python;

struct ParallelPlan_wrapper : ompl::tools::ParallelPlan, bp::wrapper< ompl::tools::ParallelPlan > {

    ParallelPlan_wrapper(::ompl::base::ProblemDefinitionPtr const & pdef )
    : ompl::tools::ParallelPlan( pdef )
      , bp::wrapper< ompl::tools::ParallelPlan >(){
        // constructor
    
    }

    void solveMore( ::ompl::base::Planner * planner, ::std::size_t minSolCount, ::std::size_t maxSolCount, ::ompl::base::PlannerTerminationCondition const * ptc ){
        ompl::tools::ParallelPlan::solveMore( boost::python::ptr(planner), minSolCount, maxSolCount, boost::python::ptr(ptc) );
    }

    void solveOne( ::ompl::base::Planner * planner, ::std::size_t minSolCount, ::ompl::base::PlannerTerminationCondition const * ptc ){
        ompl::tools::ParallelPlan::solveOne( boost::python::ptr(planner), minSolCount, boost::python::ptr(ptc) );
    }

};

void register_ParallelPlan_class(){

    { //::ompl::tools::ParallelPlan
        typedef bp::class_< ParallelPlan_wrapper, boost::noncopyable > ParallelPlan_exposer_t;
        ParallelPlan_exposer_t ParallelPlan_exposer = ParallelPlan_exposer_t( "ParallelPlan", bp::init< ompl::base::ProblemDefinitionPtr const & >(( bp::arg("pdef") )) );
        bp::scope ParallelPlan_scope( ParallelPlan_exposer );
        bp::implicitly_convertible< ompl::base::ProblemDefinitionPtr const &, ompl::tools::ParallelPlan >();
        { //::ompl::tools::ParallelPlan::addPlanner
        
            typedef void ( ::ompl::tools::ParallelPlan::*addPlanner_function_type)( ::ompl::base::PlannerPtr const & ) ;
            
            ParallelPlan_exposer.def( 
                "addPlanner"
                , addPlanner_function_type( &::ompl::tools::ParallelPlan::addPlanner )
                , ( bp::arg("planner") ) );
        
        }
        { //::ompl::tools::ParallelPlan::clearHybridizationPaths
        
            typedef void ( ::ompl::tools::ParallelPlan::*clearHybridizationPaths_function_type)(  ) ;
            
            ParallelPlan_exposer.def( 
                "clearHybridizationPaths"
                , clearHybridizationPaths_function_type( &::ompl::tools::ParallelPlan::clearHybridizationPaths ) );
        
        }
        { //::ompl::tools::ParallelPlan::clearPlanners
        
            typedef void ( ::ompl::tools::ParallelPlan::*clearPlanners_function_type)(  ) ;
            
            ParallelPlan_exposer.def( 
                "clearPlanners"
                , clearPlanners_function_type( &::ompl::tools::ParallelPlan::clearPlanners ) );
        
        }
        { //::ompl::tools::ParallelPlan::getProblemDefinition
        
            typedef ::ompl::base::ProblemDefinitionPtr const & ( ::ompl::tools::ParallelPlan::*getProblemDefinition_function_type)(  ) const;
            
            ParallelPlan_exposer.def( 
                "getProblemDefinition"
                , getProblemDefinition_function_type( &::ompl::tools::ParallelPlan::getProblemDefinition )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::ompl::tools::ParallelPlan::solve
        
            typedef ::ompl::base::PlannerStatus ( ::ompl::tools::ParallelPlan::*solve_function_type)( double,bool ) ;
            
            ParallelPlan_exposer.def( 
                "solve"
                , solve_function_type( &::ompl::tools::ParallelPlan::solve )
                , ( bp::arg("solveTime"), bp::arg("hybridize")=(bool)(true) ) );
        
        }
        { //::ompl::tools::ParallelPlan::solve
        
            typedef ::ompl::base::PlannerStatus ( ::ompl::tools::ParallelPlan::*solve_function_type)( ::ompl::base::PlannerTerminationCondition const &,bool ) ;
            
            ParallelPlan_exposer.def( 
                "solve"
                , solve_function_type( &::ompl::tools::ParallelPlan::solve )
                , ( bp::arg("ptc"), bp::arg("hybridize")=(bool)(true) ) );
        
        }
        { //::ompl::tools::ParallelPlan::solve
        
            typedef ::ompl::base::PlannerStatus ( ::ompl::tools::ParallelPlan::*solve_function_type)( double,::std::size_t,::std::size_t,bool ) ;
            
            ParallelPlan_exposer.def( 
                "solve"
                , solve_function_type( &::ompl::tools::ParallelPlan::solve )
                , ( bp::arg("solveTime"), bp::arg("minSolCount"), bp::arg("maxSolCount"), bp::arg("hybridize")=(bool)(true) ) );
        
        }
        { //::ompl::tools::ParallelPlan::solve
        
            typedef ::ompl::base::PlannerStatus ( ::ompl::tools::ParallelPlan::*solve_function_type)( ::ompl::base::PlannerTerminationCondition const &,::std::size_t,::std::size_t,bool ) ;
            
            ParallelPlan_exposer.def( 
                "solve"
                , solve_function_type( &::ompl::tools::ParallelPlan::solve )
                , ( bp::arg("ptc"), bp::arg("minSolCount"), bp::arg("maxSolCount"), bp::arg("hybridize")=(bool)(true) ) );
        
        }
        { //::ompl::tools::ParallelPlan::solveMore
        
            typedef void ( ParallelPlan_wrapper::*solveMore_function_type)( ::ompl::base::Planner *,::std::size_t,::std::size_t,::ompl::base::PlannerTerminationCondition const * ) ;
            
            ParallelPlan_exposer.def( 
                "solveMore"
                , solveMore_function_type( &ParallelPlan_wrapper::solveMore )
                , ( bp::arg("planner"), bp::arg("minSolCount"), bp::arg("maxSolCount"), bp::arg("ptc") ) );
        
        }
        { //::ompl::tools::ParallelPlan::solveOne
        
            typedef void ( ParallelPlan_wrapper::*solveOne_function_type)( ::ompl::base::Planner *,::std::size_t,::ompl::base::PlannerTerminationCondition const * ) ;
            
            ParallelPlan_exposer.def( 
                "solveOne"
                , solveOne_function_type( &ParallelPlan_wrapper::solveOne )
                , ( bp::arg("planner"), bp::arg("minSolCount"), bp::arg("ptc") ) );
        
        }
    }

}
