// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/geometric.h"
#include "PathGeometric.pypp.hpp"

namespace bp = boost::python;

struct PathGeometric_wrapper : ompl::geometric::PathGeometric, bp::wrapper< ompl::geometric::PathGeometric > {

    PathGeometric_wrapper(::ompl::base::SpaceInformationPtr const & si )
    : ompl::geometric::PathGeometric( si )
      , bp::wrapper< ompl::geometric::PathGeometric >(){
        // constructor
    
    }

    PathGeometric_wrapper(::ompl::geometric::PathGeometric const & path )
    : ompl::geometric::PathGeometric( boost::ref(path) )
      , bp::wrapper< ompl::geometric::PathGeometric >(){
        // copy constructor
    
    }

    PathGeometric_wrapper(::ompl::base::SpaceInformationPtr const & si, ::ompl::base::State const * state )
    : ompl::geometric::PathGeometric( si, boost::python::ptr(state) )
      , bp::wrapper< ompl::geometric::PathGeometric >(){
        // constructor
    
    }

    PathGeometric_wrapper(::ompl::base::SpaceInformationPtr const & si, ::ompl::base::State const * state1, ::ompl::base::State const * state2 )
    : ompl::geometric::PathGeometric( si, boost::python::ptr(state1), boost::python::ptr(state2) )
      , bp::wrapper< ompl::geometric::PathGeometric >(){
        // constructor
    
    }

    virtual bool check(  ) const  {
        if( bp::override func_check = this->get_override( "check" ) )
            return func_check(  );
        else{
            return this->ompl::geometric::PathGeometric::check(  );
        }
    }
    
    bool default_check(  ) const  {
        return ompl::geometric::PathGeometric::check( );
    }

    void copyFrom( ::ompl::geometric::PathGeometric const & other ){
        ompl::geometric::PathGeometric::copyFrom( boost::ref(other) );
    }

    void freeMemory(  ){
        ompl::geometric::PathGeometric::freeMemory(  );
    }

    virtual double length(  ) const  {
        if( bp::override func_length = this->get_override( "length" ) )
            return func_length(  );
        else{
            return this->ompl::geometric::PathGeometric::length(  );
        }
    }
    
    double default_length(  ) const  {
        return ompl::geometric::PathGeometric::length( );
    }

    virtual ::ompl::base::Cost cost( ::ompl::base::OptimizationObjectivePtr const & obj ) const  {
        if( bp::override func_cost = this->get_override( "cost" ) )
            return func_cost( obj );
        else{
            return this->ompl::base::Path::cost( obj );
        }
    }
    
    ::ompl::base::Cost default_cost( ::ompl::base::OptimizationObjectivePtr const & obj ) const  {
        return ompl::base::Path::cost( obj );
    }

};

std::string __str__(::ompl::geometric::PathGeometric* obj)
{
    std::ostringstream s;
    obj->print(s);
    return s.str();
}

std::string __printAsMatrix(::ompl::geometric::PathGeometric* path)
        {
            std::ostringstream s;
            path->printAsMatrix(s);
            return s.str();
        }

void register_PathGeometric_class(){

    { //::ompl::geometric::PathGeometric
        typedef bp::class_< PathGeometric_wrapper, bp::bases< ::ompl::base::Path > > PathGeometric_exposer_t;
        PathGeometric_exposer_t PathGeometric_exposer = PathGeometric_exposer_t( "PathGeometric", bp::init< ompl::base::SpaceInformationPtr const & >(( bp::arg("si") )) );
        bp::scope PathGeometric_scope( PathGeometric_exposer );
        bp::implicitly_convertible< ompl::base::SpaceInformationPtr const &, ompl::geometric::PathGeometric >();
        PathGeometric_exposer.def( bp::init< ompl::geometric::PathGeometric const & >(( bp::arg("path") )) );
        PathGeometric_exposer.def( bp::init< ompl::base::SpaceInformationPtr const &, ompl::base::State const * >(( bp::arg("si"), bp::arg("state") )) );
        PathGeometric_exposer.def( bp::init< ompl::base::SpaceInformationPtr const &, ompl::base::State const *, ompl::base::State const * >(( bp::arg("si"), bp::arg("state1"), bp::arg("state2") )) );
        { //::ompl::geometric::PathGeometric::append
        
            typedef void ( ::ompl::geometric::PathGeometric::*append_function_type)( ::ompl::base::State const * ) ;
            
            PathGeometric_exposer.def( 
                "append"
                , append_function_type( &::ompl::geometric::PathGeometric::append )
                , ( bp::arg("state") ) );
        
        }
        { //::ompl::geometric::PathGeometric::append
        
            typedef void ( ::ompl::geometric::PathGeometric::*append_function_type)( ::ompl::geometric::PathGeometric const & ) ;
            
            PathGeometric_exposer.def( 
                "append"
                , append_function_type( &::ompl::geometric::PathGeometric::append )
                , ( bp::arg("path") ) );
        
        }
        { //::ompl::geometric::PathGeometric::check
        
            typedef bool ( ::ompl::geometric::PathGeometric::*check_function_type)(  ) const;
            typedef bool ( PathGeometric_wrapper::*default_check_function_type)(  ) const;
            
            PathGeometric_exposer.def( 
                "check"
                , check_function_type(&::ompl::geometric::PathGeometric::check)
                , default_check_function_type(&PathGeometric_wrapper::default_check) );
        
        }
        { //::ompl::geometric::PathGeometric::checkAndRepair
        
            typedef ::std::pair< bool, bool > ( ::ompl::geometric::PathGeometric::*checkAndRepair_function_type)( unsigned int ) ;
            
            PathGeometric_exposer.def( 
                "checkAndRepair"
                , checkAndRepair_function_type( &::ompl::geometric::PathGeometric::checkAndRepair )
                , ( bp::arg("attempts") ) );
        
        }
        { //::ompl::geometric::PathGeometric::clearance
        
            typedef double ( ::ompl::geometric::PathGeometric::*clearance_function_type)(  ) const;
            
            PathGeometric_exposer.def( 
                "clearance"
                , clearance_function_type( &::ompl::geometric::PathGeometric::clearance ) );
        
        }
        { //::ompl::geometric::PathGeometric::copyFrom
        
            typedef void ( PathGeometric_wrapper::*copyFrom_function_type)( ::ompl::geometric::PathGeometric const & ) ;
            
            PathGeometric_exposer.def( 
                "copyFrom"
                , copyFrom_function_type( &PathGeometric_wrapper::copyFrom )
                , ( bp::arg("other") ) );
        
        }
        { //::ompl::geometric::PathGeometric::freeMemory
        
            typedef void ( PathGeometric_wrapper::*freeMemory_function_type)(  ) ;
            
            PathGeometric_exposer.def( 
                "freeMemory"
                , freeMemory_function_type( &PathGeometric_wrapper::freeMemory ) );
        
        }
        { //::ompl::geometric::PathGeometric::getClosestIndex
        
            typedef int ( ::ompl::geometric::PathGeometric::*getClosestIndex_function_type)( ::ompl::base::State const * ) const;
            
            PathGeometric_exposer.def( 
                "getClosestIndex"
                , getClosestIndex_function_type( &::ompl::geometric::PathGeometric::getClosestIndex )
                , ( bp::arg("state") ) );
        
        }
        { //::ompl::geometric::PathGeometric::getState
        
            typedef ::ompl::base::State * ( ::ompl::geometric::PathGeometric::*getState_function_type)( unsigned int ) ;
            
            PathGeometric_exposer.def( 
                "getState"
                , getState_function_type( &::ompl::geometric::PathGeometric::getState )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ompl::geometric::PathGeometric::getState
        
            typedef ::ompl::base::State const * ( ::ompl::geometric::PathGeometric::*getState_function_type)( unsigned int ) const;
            
            PathGeometric_exposer.def( 
                "getState"
                , getState_function_type( &::ompl::geometric::PathGeometric::getState )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ompl::geometric::PathGeometric::getStateCount
        
            typedef ::std::size_t ( ::ompl::geometric::PathGeometric::*getStateCount_function_type)(  ) const;
            
            PathGeometric_exposer.def( 
                "getStateCount"
                , getStateCount_function_type( &::ompl::geometric::PathGeometric::getStateCount ) );
        
        }
        { //::ompl::geometric::PathGeometric::getStates
        
            typedef ::std::vector< ompl::base::State* > & ( ::ompl::geometric::PathGeometric::*getStates_function_type)(  ) ;
            
            PathGeometric_exposer.def( 
                "getStates"
                , getStates_function_type( &::ompl::geometric::PathGeometric::getStates )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ompl::geometric::PathGeometric::interpolate
        
            typedef void ( ::ompl::geometric::PathGeometric::*interpolate_function_type)( unsigned int ) ;
            
            PathGeometric_exposer.def( 
                "interpolate"
                , interpolate_function_type( &::ompl::geometric::PathGeometric::interpolate )
                , ( bp::arg("count") ) );
        
        }
        { //::ompl::geometric::PathGeometric::interpolate
        
            typedef void ( ::ompl::geometric::PathGeometric::*interpolate_function_type)(  ) ;
            
            PathGeometric_exposer.def( 
                "interpolate"
                , interpolate_function_type( &::ompl::geometric::PathGeometric::interpolate ) );
        
        }
        { //::ompl::geometric::PathGeometric::keepAfter
        
            typedef void ( ::ompl::geometric::PathGeometric::*keepAfter_function_type)( ::ompl::base::State const * ) ;
            
            PathGeometric_exposer.def( 
                "keepAfter"
                , keepAfter_function_type( &::ompl::geometric::PathGeometric::keepAfter )
                , ( bp::arg("state") ) );
        
        }
        { //::ompl::geometric::PathGeometric::keepBefore
        
            typedef void ( ::ompl::geometric::PathGeometric::*keepBefore_function_type)( ::ompl::base::State const * ) ;
            
            PathGeometric_exposer.def( 
                "keepBefore"
                , keepBefore_function_type( &::ompl::geometric::PathGeometric::keepBefore )
                , ( bp::arg("state") ) );
        
        }
        { //::ompl::geometric::PathGeometric::length
        
            typedef double ( ::ompl::geometric::PathGeometric::*length_function_type)(  ) const;
            typedef double ( PathGeometric_wrapper::*default_length_function_type)(  ) const;
            
            PathGeometric_exposer.def( 
                "length"
                , length_function_type(&::ompl::geometric::PathGeometric::length)
                , default_length_function_type(&PathGeometric_wrapper::default_length) );
        
        }
        { //::ompl::geometric::PathGeometric::operator=
        
            typedef ::ompl::geometric::PathGeometric & ( ::ompl::geometric::PathGeometric::*assign_function_type)( ::ompl::geometric::PathGeometric const & ) ;
            
            PathGeometric_exposer.def( 
                "assign"
                , assign_function_type( &::ompl::geometric::PathGeometric::operator= )
                , ( bp::arg("other") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ompl::geometric::PathGeometric::overlay
        
            typedef void ( ::ompl::geometric::PathGeometric::*overlay_function_type)( ::ompl::geometric::PathGeometric const &,unsigned int ) ;
            
            PathGeometric_exposer.def( 
                "overlay"
                , overlay_function_type( &::ompl::geometric::PathGeometric::overlay )
                , ( bp::arg("over"), bp::arg("startIndex")=(unsigned int)(0) ) );
        
        }
        { //::ompl::geometric::PathGeometric::random
        
            typedef void ( ::ompl::geometric::PathGeometric::*random_function_type)(  ) ;
            
            PathGeometric_exposer.def( 
                "random"
                , random_function_type( &::ompl::geometric::PathGeometric::random ) );
        
        }
        { //::ompl::geometric::PathGeometric::randomValid
        
            typedef bool ( ::ompl::geometric::PathGeometric::*randomValid_function_type)( unsigned int ) ;
            
            PathGeometric_exposer.def( 
                "randomValid"
                , randomValid_function_type( &::ompl::geometric::PathGeometric::randomValid )
                , ( bp::arg("attempts") ) );
        
        }
        { //::ompl::geometric::PathGeometric::reverse
        
            typedef void ( ::ompl::geometric::PathGeometric::*reverse_function_type)(  ) ;
            
            PathGeometric_exposer.def( 
                "reverse"
                , reverse_function_type( &::ompl::geometric::PathGeometric::reverse ) );
        
        }
        { //::ompl::geometric::PathGeometric::smoothness
        
            typedef double ( ::ompl::geometric::PathGeometric::*smoothness_function_type)(  ) const;
            
            PathGeometric_exposer.def( 
                "smoothness"
                , smoothness_function_type( &::ompl::geometric::PathGeometric::smoothness ) );
        
        }
        { //::ompl::geometric::PathGeometric::subdivide
        
            typedef void ( ::ompl::geometric::PathGeometric::*subdivide_function_type)(  ) ;
            
            PathGeometric_exposer.def( 
                "subdivide"
                , subdivide_function_type( &::ompl::geometric::PathGeometric::subdivide ) );
        
        }
        PathGeometric_exposer.def("__str__", &__str__);
        PathGeometric_exposer.def("printAsMatrix", &__printAsMatrix);
    }

}
