// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/control.h"
#include "StatePropagator.pypp.hpp"

namespace bp = boost::python;

struct StatePropagator_wrapper : ompl::control::StatePropagator, bp::wrapper< ompl::control::StatePropagator > {

    StatePropagator_wrapper(::ompl::control::SpaceInformation * si )
    : ompl::control::StatePropagator( boost::python::ptr(si) )
      , bp::wrapper< ompl::control::StatePropagator >(){
        // constructor
    
    }

    StatePropagator_wrapper(::ompl::control::SpaceInformationPtr const & si )
    : ompl::control::StatePropagator( si )
      , bp::wrapper< ompl::control::StatePropagator >(){
        // constructor
    
    }

    virtual bool canPropagateBackward(  ) const  {
        if( bp::override func_canPropagateBackward = this->get_override( "canPropagateBackward" ) )
            return func_canPropagateBackward(  );
        else{
            return this->ompl::control::StatePropagator::canPropagateBackward(  );
        }
    }
    
    bool default_canPropagateBackward(  ) const  {
        return ompl::control::StatePropagator::canPropagateBackward( );
    }

    virtual bool canSteer(  ) const  {
        if( bp::override func_canSteer = this->get_override( "canSteer" ) )
            return func_canSteer(  );
        else{
            return this->ompl::control::StatePropagator::canSteer(  );
        }
    }
    
    bool default_canSteer(  ) const  {
        return ompl::control::StatePropagator::canSteer( );
    }

    virtual void propagate( ::ompl::base::State const * state, ::ompl::control::Control const * control, double const duration, ::ompl::base::State * result ) const {
        bp::override func_propagate = this->get_override( "propagate" );
        func_propagate( boost::python::ptr(state), boost::python::ptr(control), duration, boost::python::ptr(result) );
    }

    virtual bool steer( ::ompl::base::State const * arg0, ::ompl::base::State const * arg1, ::ompl::control::Control * arg2, double & arg3 ) const  {
        if( bp::override func_steer = this->get_override( "steer" ) )
            return func_steer( boost::python::ptr(arg0), boost::python::ptr(arg1), boost::python::ptr(arg2), arg3 );
        else{
            return this->ompl::control::StatePropagator::steer( boost::python::ptr(arg0), boost::python::ptr(arg1), boost::python::ptr(arg2), arg3 );
        }
    }
    
    bool default_steer( ::ompl::base::State const * arg0, ::ompl::base::State const * arg1, ::ompl::control::Control * arg2, double & arg3 ) const  {
        return ompl::control::StatePropagator::steer( boost::python::ptr(arg0), boost::python::ptr(arg1), boost::python::ptr(arg2), arg3 );
    }

};

void register_StatePropagator_class(){

    { //::ompl::control::StatePropagator
        typedef bp::class_< StatePropagator_wrapper, boost::noncopyable > StatePropagator_exposer_t;
        StatePropagator_exposer_t StatePropagator_exposer = StatePropagator_exposer_t( "StatePropagator", bp::init< ompl::control::SpaceInformation * >(( bp::arg("si") )) );
        bp::scope StatePropagator_scope( StatePropagator_exposer );
        StatePropagator_exposer.def( bp::init< ompl::control::SpaceInformationPtr const & >(( bp::arg("si") )) );
        { //::ompl::control::StatePropagator::canPropagateBackward
        
            typedef bool ( ::ompl::control::StatePropagator::*canPropagateBackward_function_type)(  ) const;
            typedef bool ( StatePropagator_wrapper::*default_canPropagateBackward_function_type)(  ) const;
            
            StatePropagator_exposer.def( 
                "canPropagateBackward"
                , canPropagateBackward_function_type(&::ompl::control::StatePropagator::canPropagateBackward)
                , default_canPropagateBackward_function_type(&StatePropagator_wrapper::default_canPropagateBackward) );
        
        }
        { //::ompl::control::StatePropagator::canSteer
        
            typedef bool ( ::ompl::control::StatePropagator::*canSteer_function_type)(  ) const;
            typedef bool ( StatePropagator_wrapper::*default_canSteer_function_type)(  ) const;
            
            StatePropagator_exposer.def( 
                "canSteer"
                , canSteer_function_type(&::ompl::control::StatePropagator::canSteer)
                , default_canSteer_function_type(&StatePropagator_wrapper::default_canSteer) );
        
        }
        { //::ompl::control::StatePropagator::propagate
        
            typedef void ( ::ompl::control::StatePropagator::*propagate_function_type)( ::ompl::base::State const *,::ompl::control::Control const *,double const,::ompl::base::State * ) const;
            
            StatePropagator_exposer.def( 
                "propagate"
                , bp::pure_virtual( propagate_function_type(&::ompl::control::StatePropagator::propagate) )
                , ( bp::arg("state"), bp::arg("control"), bp::arg("duration"), bp::arg("result") ) );
        
        }
        { //::ompl::control::StatePropagator::steer
        
            typedef bool ( ::ompl::control::StatePropagator::*steer_function_type)( ::ompl::base::State const *,::ompl::base::State const *,::ompl::control::Control *,double & ) const;
            typedef bool ( StatePropagator_wrapper::*default_steer_function_type)( ::ompl::base::State const *,::ompl::base::State const *,::ompl::control::Control *,double & ) const;
            
            StatePropagator_exposer.def( 
                "steer"
                , steer_function_type(&::ompl::control::StatePropagator::steer)
                , default_steer_function_type(&StatePropagator_wrapper::default_steer)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2"), bp::arg("arg3") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< ompl::control::StatePropagator > >();
    }

}
