// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/control.h"
#include "ODEAdaptiveSolver.pypp.hpp"

namespace bp = boost::python;

struct ODEAdaptiveSolver_less__boost_scope_numeric_scope_odeint_scope_runge_kutta_cash_karp54_less__std_scope_vector_less__double__greater__comma__double_comma__std_scope_vector_less__double__greater__comma__double_comma__boost_scope_numeric_scope_odeint_scope_range_algebra_comma__boost_scope_numeric_scope_odeint_scope_default_operations_comma__boost_scope_numeric_scope_odeint_scope_initially_resizer__greater___greater__wrapper : ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >, bp::wrapper< ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > > {

    ODEAdaptiveSolver_less__boost_scope_numeric_scope_odeint_scope_runge_kutta_cash_karp54_less__std_scope_vector_less__double__greater__comma__double_comma__std_scope_vector_less__double__greater__comma__double_comma__boost_scope_numeric_scope_odeint_scope_range_algebra_comma__boost_scope_numeric_scope_odeint_scope_default_operations_comma__boost_scope_numeric_scope_odeint_scope_initially_resizer__greater___greater__wrapper(::boost::shared_ptr< ompl::control::SpaceInformation > const & si, ::boost::function< void (std::vector< double, std::allocator< double > >, ompl::control::Control const*, std::vector<double, std::allocator<double> >&) > const & ode, double intStep=1.00000000000000002081668171172168513294309377670288085938e-2 )
    : ompl::control::ODEAdaptiveSolver<boost::numeric::odeint::runge_kutta_cash_karp54<std::vector<double, std::allocator<double> >, double, std::vector<double, std::allocator<double> >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer> >( si, boost::ref(ode), intStep )
      , bp::wrapper< ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > >(){
        // constructor
    
    }

    virtual void solve( ::std::vector< double > & state, ::ompl::control::Control const * control, double const duration ) const {
        if( bp::override func_solve = this->get_override( "solve" ) )
            func_solve( boost::ref(state), boost::python::ptr(control), duration );
        else{
            this->ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::solve( boost::ref(state), boost::python::ptr(control), duration );
        }
    }
    
    virtual void default_solve( ::std::vector< double > & state, ::ompl::control::Control const * control, double const duration ) const {
        ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::solve( boost::ref(state), boost::python::ptr(control), duration );
    }

};

void register_ODEAdaptiveSolver_class(){

    { //::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >
        typedef bp::class_< ODEAdaptiveSolver_less__boost_scope_numeric_scope_odeint_scope_runge_kutta_cash_karp54_less__std_scope_vector_less__double__greater__comma__double_comma__std_scope_vector_less__double__greater__comma__double_comma__boost_scope_numeric_scope_odeint_scope_range_algebra_comma__boost_scope_numeric_scope_odeint_scope_default_operations_comma__boost_scope_numeric_scope_odeint_scope_initially_resizer__greater___greater__wrapper, bp::bases< ompl::control::ODESolver >, boost::noncopyable > ODEAdaptiveSolver_exposer_t;
        ODEAdaptiveSolver_exposer_t ODEAdaptiveSolver_exposer = ODEAdaptiveSolver_exposer_t( "ODEAdaptiveSolver", bp::init< boost::shared_ptr< ompl::control::SpaceInformation > const &, boost::function< void (std::vector< double, std::allocator< double > >, ompl::control::Control const*, std::vector<double, std::allocator<double> >&) > const &, bp::optional< double > >(( bp::arg("si"), bp::arg("ode"), bp::arg("intStep")=1.00000000000000002081668171172168513294309377670288085938e-2 )) );
        bp::scope ODEAdaptiveSolver_scope( ODEAdaptiveSolver_exposer );
        { //::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::getMaximumEpsilonError
        
            typedef ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > exported_class_t;
            typedef double ( exported_class_t::*getMaximumEpsilonError_function_type)(  ) const;
            
            ODEAdaptiveSolver_exposer.def( 
                "getMaximumEpsilonError"
                , getMaximumEpsilonError_function_type( &::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::getMaximumEpsilonError ) );
        
        }
        { //::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::getMaximumError
        
            typedef ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > exported_class_t;
            typedef double ( exported_class_t::*getMaximumError_function_type)(  ) const;
            
            ODEAdaptiveSolver_exposer.def( 
                "getMaximumError"
                , getMaximumError_function_type( &::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::getMaximumError ) );
        
        }
        { //::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::setMaximumEpsilonError
        
            typedef ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > exported_class_t;
            typedef void ( exported_class_t::*setMaximumEpsilonError_function_type)( double ) ;
            
            ODEAdaptiveSolver_exposer.def( 
                "setMaximumEpsilonError"
                , setMaximumEpsilonError_function_type( &::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::setMaximumEpsilonError )
                , ( bp::arg("error") ) );
        
        }
        { //::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::setMaximumError
        
            typedef ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > exported_class_t;
            typedef void ( exported_class_t::*setMaximumError_function_type)( double ) ;
            
            ODEAdaptiveSolver_exposer.def( 
                "setMaximumError"
                , setMaximumError_function_type( &::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::setMaximumError )
                , ( bp::arg("error") ) );
        
        }
        { //::ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > >::solve
        
            typedef ompl::control::ODEAdaptiveSolver< boost::numeric::odeint::runge_kutta_cash_karp54< std::vector< double >, double, std::vector< double >, double, boost::numeric::odeint::range_algebra, boost::numeric::odeint::default_operations, boost::numeric::odeint::initially_resizer > > exported_class_t;
            typedef void ( ODEAdaptiveSolver_less__boost_scope_numeric_scope_odeint_scope_runge_kutta_cash_karp54_less__std_scope_vector_less__double__greater__comma__double_comma__std_scope_vector_less__double__greater__comma__double_comma__boost_scope_numeric_scope_odeint_scope_range_algebra_comma__boost_scope_numeric_scope_odeint_scope_default_operations_comma__boost_scope_numeric_scope_odeint_scope_initially_resizer__greater___greater__wrapper::*solve_function_type)( ::std::vector< double > &,::ompl::control::Control const *,double const ) const;
            
            ODEAdaptiveSolver_exposer.def( 
                "solve"
                , solve_function_type( &ODEAdaptiveSolver_less__boost_scope_numeric_scope_odeint_scope_runge_kutta_cash_karp54_less__std_scope_vector_less__double__greater__comma__double_comma__std_scope_vector_less__double__greater__comma__double_comma__boost_scope_numeric_scope_odeint_scope_range_algebra_comma__boost_scope_numeric_scope_odeint_scope_default_operations_comma__boost_scope_numeric_scope_odeint_scope_initially_resizer__greater___greater__wrapper::default_solve )
                , ( bp::arg("state"), bp::arg("control"), bp::arg("duration") ) );
        
        }
    }

}
