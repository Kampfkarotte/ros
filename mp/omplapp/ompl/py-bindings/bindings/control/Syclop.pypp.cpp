// This file has been generated by Py++.

#include "boost/python.hpp"
#include "bindings/control.h"
#include "Syclop.pypp.hpp"

namespace bp = boost::python;

struct ControlSyclop_wrapper : ompl::control::Syclop, bp::wrapper< ompl::control::Syclop > {

    ControlSyclop_wrapper(::ompl::control::SpaceInformationPtr const & si, ::ompl::control::DecompositionPtr const & d, ::std::string const & plannerName )
    : ompl::control::Syclop( si, d, plannerName )
      , bp::wrapper< ompl::control::Syclop >(){
        // constructor
    
    }

    virtual void clear(  ) {
        if( bp::override func_clear = this->get_override( "clear" ) )
            func_clear(  );
        else{
            this->ompl::control::Syclop::clear(  );
        }
    }
    
    void default_clear(  ) {
        ompl::control::Syclop::clear( );
    }

    virtual void setup(  ) {
        if( bp::override func_setup = this->get_override( "setup" ) )
            func_setup(  );
        else{
            this->ompl::control::Syclop::setup(  );
        }
    }
    
    void default_setup(  ) {
        ompl::control::Syclop::setup( );
    }

    virtual ::ompl::base::PlannerStatus solve( ::ompl::base::PlannerTerminationCondition const & ptc ) {
        if( bp::override func_solve = this->get_override( "solve" ) )
            return func_solve( boost::ref(ptc) );
        else{
            return this->ompl::control::Syclop::solve( boost::ref(ptc) );
        }
    }
    
    ::ompl::base::PlannerStatus default_solve( ::ompl::base::PlannerTerminationCondition const & ptc ) {
        return ompl::control::Syclop::solve( boost::ref(ptc) );
    }

    virtual void checkValidity(  ) {
        if( bp::override func_checkValidity = this->get_override( "checkValidity" ) )
            func_checkValidity(  );
        else{
            this->ompl::base::Planner::checkValidity(  );
        }
    }
    
    void default_checkValidity(  ) {
        ompl::base::Planner::checkValidity( );
    }

    virtual void getPlannerData( ::ompl::base::PlannerData & data ) const  {
        if( bp::override func_getPlannerData = this->get_override( "getPlannerData" ) )
            func_getPlannerData( boost::ref(data) );
        else{
            this->ompl::base::Planner::getPlannerData( boost::ref(data) );
        }
    }
    
    void default_getPlannerData( ::ompl::base::PlannerData & data ) const  {
        ompl::base::Planner::getPlannerData( boost::ref(data) );
    }

    virtual void setProblemDefinition( ::ompl::base::ProblemDefinitionPtr const & pdef ) {
        if( bp::override func_setProblemDefinition = this->get_override( "setProblemDefinition" ) )
            func_setProblemDefinition( pdef );
        else{
            this->ompl::base::Planner::setProblemDefinition( pdef );
        }
    }
    
    void default_setProblemDefinition( ::ompl::base::ProblemDefinitionPtr const & pdef ) {
        ompl::base::Planner::setProblemDefinition( pdef );
    }

    virtual ompl::control::Syclop::Motion* addRoot(const ompl::base::State* s)
            {
                bp::override func_addRoot = this->get_override("addRoot");
                return func_addRoot(s);
            }
            virtual void selectAndExtend(ompl::control::Syclop::Region& region, std::vector<ompl::control::Syclop::Motion*>& newMotions)
            {
                bp::override func_selectAndExtend = this->get_override("selectAndExtend");
                func_selectAndExtend(region, newMotions);
            }

};

void register_Syclop_class(){

    { //::ompl::control::Syclop
        typedef bp::class_< ControlSyclop_wrapper, bp::bases< ::ompl::base::Planner >, boost::noncopyable > Syclop_exposer_t;
        Syclop_exposer_t Syclop_exposer = Syclop_exposer_t( "Syclop", bp::init< ompl::control::SpaceInformationPtr const &, ompl::control::DecompositionPtr const &, std::string const & >(( bp::arg("si"), bp::arg("d"), bp::arg("plannerName") )) );
        bp::scope Syclop_scope( Syclop_exposer );
        { //::ompl::control::Syclop::addEdgeCostFactor
        
            typedef void ( ::ompl::control::Syclop::*addEdgeCostFactor_function_type)( ::boost::function< double (int, int) > const & ) ;
            
            Syclop_exposer.def( 
                "addEdgeCostFactor"
                , addEdgeCostFactor_function_type( &::ompl::control::Syclop::addEdgeCostFactor )
                , ( bp::arg("factor") ) );
        
        }
        { //::ompl::control::Syclop::clear
        
            typedef void ( ::ompl::control::Syclop::*clear_function_type)(  ) ;
            typedef void ( ControlSyclop_wrapper::*default_clear_function_type)(  ) ;
            
            Syclop_exposer.def( 
                "clear"
                , clear_function_type(&::ompl::control::Syclop::clear)
                , default_clear_function_type(&ControlSyclop_wrapper::default_clear) );
        
        }
        { //::ompl::control::Syclop::clearEdgeCostFactors
        
            typedef void ( ::ompl::control::Syclop::*clearEdgeCostFactors_function_type)(  ) ;
            
            Syclop_exposer.def( 
                "clearEdgeCostFactors"
                , clearEdgeCostFactors_function_type( &::ompl::control::Syclop::clearEdgeCostFactors ) );
        
        }
        { //::ompl::control::Syclop::getNumFreeVolumeSamples
        
            typedef int ( ::ompl::control::Syclop::*getNumFreeVolumeSamples_function_type)(  ) const;
            
            Syclop_exposer.def( 
                "getNumFreeVolumeSamples"
                , getNumFreeVolumeSamples_function_type( &::ompl::control::Syclop::getNumFreeVolumeSamples ) );
        
        }
        { //::ompl::control::Syclop::getNumRegionExpansions
        
            typedef int ( ::ompl::control::Syclop::*getNumRegionExpansions_function_type)(  ) const;
            
            Syclop_exposer.def( 
                "getNumRegionExpansions"
                , getNumRegionExpansions_function_type( &::ompl::control::Syclop::getNumRegionExpansions ) );
        
        }
        { //::ompl::control::Syclop::getNumTreeExpansions
        
            typedef int ( ::ompl::control::Syclop::*getNumTreeExpansions_function_type)(  ) const;
            
            Syclop_exposer.def( 
                "getNumTreeExpansions"
                , getNumTreeExpansions_function_type( &::ompl::control::Syclop::getNumTreeExpansions ) );
        
        }
        { //::ompl::control::Syclop::getProbAbandonLeadEarly
        
            typedef double ( ::ompl::control::Syclop::*getProbAbandonLeadEarly_function_type)(  ) const;
            
            Syclop_exposer.def( 
                "getProbAbandonLeadEarly"
                , getProbAbandonLeadEarly_function_type( &::ompl::control::Syclop::getProbAbandonLeadEarly ) );
        
        }
        { //::ompl::control::Syclop::getProbAddingToAvailableRegions
        
            typedef double ( ::ompl::control::Syclop::*getProbAddingToAvailableRegions_function_type)(  ) const;
            
            Syclop_exposer.def( 
                "getProbAddingToAvailableRegions"
                , getProbAddingToAvailableRegions_function_type( &::ompl::control::Syclop::getProbAddingToAvailableRegions ) );
        
        }
        { //::ompl::control::Syclop::getProbShortestPathLead
        
            typedef double ( ::ompl::control::Syclop::*getProbShortestPathLead_function_type)(  ) const;
            
            Syclop_exposer.def( 
                "getProbShortestPathLead"
                , getProbShortestPathLead_function_type( &::ompl::control::Syclop::getProbShortestPathLead ) );
        
        }
        { //::ompl::control::Syclop::setLeadComputeFn
        
            typedef void ( ::ompl::control::Syclop::*setLeadComputeFn_function_type)( ::boost::function< void (int, int, std::vector<int, std::allocator<int> >&) > const & ) ;
            
            Syclop_exposer.def( 
                "setLeadComputeFn"
                , setLeadComputeFn_function_type( &::ompl::control::Syclop::setLeadComputeFn )
                , ( bp::arg("compute") ) );
        
        }
        { //::ompl::control::Syclop::setNumFreeVolumeSamples
        
            typedef void ( ::ompl::control::Syclop::*setNumFreeVolumeSamples_function_type)( int ) ;
            
            Syclop_exposer.def( 
                "setNumFreeVolumeSamples"
                , setNumFreeVolumeSamples_function_type( &::ompl::control::Syclop::setNumFreeVolumeSamples )
                , ( bp::arg("numSamples") ) );
        
        }
        { //::ompl::control::Syclop::setNumRegionExpansions
        
            typedef void ( ::ompl::control::Syclop::*setNumRegionExpansions_function_type)( int ) ;
            
            Syclop_exposer.def( 
                "setNumRegionExpansions"
                , setNumRegionExpansions_function_type( &::ompl::control::Syclop::setNumRegionExpansions )
                , ( bp::arg("regionExpansions") ) );
        
        }
        { //::ompl::control::Syclop::setNumTreeExpansions
        
            typedef void ( ::ompl::control::Syclop::*setNumTreeExpansions_function_type)( int ) ;
            
            Syclop_exposer.def( 
                "setNumTreeExpansions"
                , setNumTreeExpansions_function_type( &::ompl::control::Syclop::setNumTreeExpansions )
                , ( bp::arg("treeExpansions") ) );
        
        }
        { //::ompl::control::Syclop::setProbAbandonLeadEarly
        
            typedef void ( ::ompl::control::Syclop::*setProbAbandonLeadEarly_function_type)( double ) ;
            
            Syclop_exposer.def( 
                "setProbAbandonLeadEarly"
                , setProbAbandonLeadEarly_function_type( &::ompl::control::Syclop::setProbAbandonLeadEarly )
                , ( bp::arg("probability") ) );
        
        }
        { //::ompl::control::Syclop::setProbAddingToAvailableRegions
        
            typedef void ( ::ompl::control::Syclop::*setProbAddingToAvailableRegions_function_type)( double ) ;
            
            Syclop_exposer.def( 
                "setProbAddingToAvailableRegions"
                , setProbAddingToAvailableRegions_function_type( &::ompl::control::Syclop::setProbAddingToAvailableRegions )
                , ( bp::arg("probability") ) );
        
        }
        { //::ompl::control::Syclop::setProbShortestPathLead
        
            typedef void ( ::ompl::control::Syclop::*setProbShortestPathLead_function_type)( double ) ;
            
            Syclop_exposer.def( 
                "setProbShortestPathLead"
                , setProbShortestPathLead_function_type( &::ompl::control::Syclop::setProbShortestPathLead )
                , ( bp::arg("probability") ) );
        
        }
        { //::ompl::control::Syclop::setup
        
            typedef void ( ::ompl::control::Syclop::*setup_function_type)(  ) ;
            typedef void ( ControlSyclop_wrapper::*default_setup_function_type)(  ) ;
            
            Syclop_exposer.def( 
                "setup"
                , setup_function_type(&::ompl::control::Syclop::setup)
                , default_setup_function_type(&ControlSyclop_wrapper::default_setup) );
        
        }
        { //::ompl::control::Syclop::solve
        
            typedef ::ompl::base::PlannerStatus ( ::ompl::control::Syclop::*solve_function_type)( ::ompl::base::PlannerTerminationCondition const & ) ;
            typedef ::ompl::base::PlannerStatus ( ControlSyclop_wrapper::*default_solve_function_type)( ::ompl::base::PlannerTerminationCondition const & ) ;
            
            Syclop_exposer.def( 
                "solve"
                , solve_function_type(&::ompl::control::Syclop::solve)
                , default_solve_function_type(&ControlSyclop_wrapper::default_solve)
                , ( bp::arg("ptc") ) );
        
        }
        Syclop_exposer.def("solve", (::ompl::base::PlannerStatus(::ompl::base::Planner::*)( double ))(&::ompl::base::Planner::solve), (bp::arg("solveTime")) );
        Syclop_exposer.def("setProblemDefinition",&::ompl::base::Planner::setProblemDefinition,
                            &ControlSyclop_wrapper::default_setProblemDefinition, (bp::arg("pdef")) );
        Syclop_exposer.def("checkValidity",&::ompl::base::Planner::checkValidity,
                            &ControlSyclop_wrapper::default_checkValidity );
    }

}
